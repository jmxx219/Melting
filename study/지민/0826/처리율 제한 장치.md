### 처리율 제한 장치

> 처리율 제한 장치: 클라이언트 또는 서비스가 보내는 트래픽의 처리율을 제어하기 위한 장치
- API에 처리율 제한 장치를 두면 좋은 점
    - Dos 공격에 의한 자원 고갈 방지
    - 비용 절감
    - 서버 과부하 막음
- 클라우드 마이크로 서비스에서 처리율 제한 장치는 API 게이트웨이라고 불리는 컴포넌트에 구현됨
    - API 게이트웨이: 처리율 제한, 사용자 인증, SSL 종단 등을 지원하며, 클라우드 업체가 유지보수를 담당하는 서비스

<br>

### 처리율 제한 알고리즘

- `토큰 버킷`: 사전 설정된 양의 토큰이 주기적으로 채워지고, 각 요청마다 하나의 토큰을 사용함. 토큰이 꽉 찬 버킷은 더 이상의 토큰이 추가되지 않고, 토큰이 없다면 요청은 버려짐
- `누출 버킷`: 큐에 빈자리가 있으면 요청을 추가하고, 가득 차있으면 새 요청을 버림. 지정된 시간마다 요청을 꺼내서 처리
- `고정 윈도 카운터`: 타임라인을 고정된 간격의 윈도로 나누고, 윈도마다 카운터를 붙여 요청이 접수될 때마다 카운터의 값을 1 증가시킴. 이 카운터의 값이 설정된 임계치에 도달하면 새로운 요청은 새 윈도가 열릴 때까지 버려짐
- `이동 윈도 로그`: 새 요청이 오면 만료된 타임스탬프는 제거하고, 새 요청의 타임스탬프를 로그에 추가함. 로그의 크기가 허용치보다 작거나 같으면 요청을 시스템에 전달하고, 그렇지 않으면 요청 처리를 거부함
- `이동 윈도 카운터`: 고정 윈도 카운터 + 이동 윈도 로그 결합.

<br>

- 얼마나 많은 요청이 접수되었는지를 추적할 수 있는 카운터를 두고, 카운터의 값이 한도를 넘어가면 요청은 거부된다.
    - 이 카운터는 보통 캐시에서 보관하는게 바람직하다.
    - 클라이언트가 처리율 제한 미들웨어에게 요청을 보내면, 레디스의 지정 버킷에서 카운터를 가져와 한도를 검사한다. 한도에 도달되면 요청은 거부되고, 아니면 API 서버로 전달하면서 카운터의 값을 증가시켜 레디스에 저장한다.
- 어떤 요청이 한도 제한에 걸리면 API는 HTTP 429 응답(too many requests)를 클라이언트에게 보냄.
    - 경우에 따라 한도 제한에 걸린 메시지를 나중에 처리하기 위해 큐에 보관할 수도 있음
- 처리율 제한 장치가 사용하는 HTTP 헤더
    - 클라이언트는 자기 요청이 처리율 제한에 걸리고 있는지, 제한에 걸리기까지 얼마나 많은 요청을 보낼 수 있는지를 HTTP 응답 헤더를 통해 알 수 있다.
- 분산 환경에서 처리율 제한 장치를 구현하는 것은 어렵다.
    - 경쟁 조건과 동기화 두 가지 문제를 해결해야 한다.
    - 경쟁 조건 문제를 해결하는 가장 널리 알려진 해결책은 락(lock)이지만 시스템의 성능을 상당히 떨어뜨림. 락 대신 쓸 수 있는 방법으로 루아 스크립트와 정렬 집합을 사용하면 됨
    - 동기화 문제를 해결하기 위해 sticky session을 활용하여 같은 클라이언트로부터의 요청은 항상 같은 처리율 제한 장치로 보낼 수 있다. 하지만 이는 확장이 가능하지도 않고 유연하지도 않아서 추천하지 않는다.
        - 더 나은 방법은 레디스와 같은 중앙 집중형 데이터 저장소를 사용하는 것. (데이터의 일관성)
- 처리율 제한 장치를 설치한 이후에는 채택된 처리율 제한 알고리즘이 효과적인지, 정의한 처리율 제한 규칙이 효과적인지 확인하기 위해 모니터링을 한다.